<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surgical Edits Dataset Reviewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .diff-added { background-color: rgba(134, 239, 172, 0.3); color: inherit; padding: 2px 4px; border-radius: 3px; }
        .diff-removed { background-color: rgba(252, 165, 165, 0.3); color: inherit; padding: 2px 4px; border-radius: 3px; }
        .diff-neutral { background-color: #f3f4f6; }
        .mechanism-toxic { border-left: 4px solid #ef4444; }
        .mechanism-omission { border-left: 4px solid #3b82f6; }
        .note-good { background-color: #dcfce7; }
        .note-bad { background-color: #fee2e2; }
        .note-unrealistic { background-color: #fef3c7; }
        textarea { resize: vertical; }
        .sticky-header { position: sticky; top: 0; z-index: 10; background: white; border-bottom: 2px solid #e5e7eb; }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="w-full max-w-[1800px] mx-auto bg-white shadow-2xl rounded-lg overflow-hidden">
        <!-- Header -->
        <div class="sticky-header p-6 border-b">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">Surgical Edits Dataset Reviewer</h1>
            <p class="text-gray-600 mb-4">Review and annotate degradation examples side-by-side</p>
            
            <!-- Filters and Stats -->
            <div class="flex flex-wrap items-center gap-4 mb-4">
                <div class="flex items-center gap-2">
                    <label class="text-sm font-medium text-gray-700">Filter by Mechanism:</label>
                    <select id="mechanismFilter" class="border border-gray-300 rounded-md px-3 py-1 text-sm">
                        <option value="all">All</option>
                        <option value="TOXIC_INJECTION">TOXIC_INJECTION</option>
                        <option value="CRITICAL_OMISSION">CRITICAL_OMISSION</option>
                    </select>
                </div>
                <div class="flex items-center gap-2">
                    <label class="text-sm font-medium text-gray-700">Filter by Rubric:</label>
                    <select id="rubricFilter" class="border border-gray-300 rounded-md px-3 py-1 text-sm">
                        <option value="all">All</option>
                    </select>
                </div>
                <div class="ml-auto flex items-center gap-4 text-sm">
                    <span id="progressText" class="font-medium text-gray-700">Loading...</span>
                    <button id="saveNotesBtn" class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 transition">
                        üíæ Save Notes
                    </button>
                    <button id="exportNotesBtn" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition">
                        üì• Export JSON
                    </button>
                </div>
            </div>
            
            <!-- File Input -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">Load Dataset:</label>
                <input type="file" id="datasetInput" accept=".json" class="text-sm">
            </div>
        </div>

        <!-- Main Content Area -->
        <div id="mainContent" class="p-6">
            <div class="text-center text-gray-500 py-12">
                <p class="text-lg">Please load a dataset file to begin reviewing</p>
                <p class="text-sm mt-2">Or use the default: ./data/surgical_edits_dataset.json</p>
            </div>
        </div>
    </div>

    <script>
        let dataset = [];
        let filteredDataset = [];
        let notes = {}; // { offer_id: { quality, note, tags } }
        
        // Load notes from localStorage or file
        function loadNotes() {
            const saved = localStorage.getItem('surgical_edits_notes');
            if (saved) {
                try {
                    notes = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading notes:', e);
                }
            }
        }
        
        // Save notes to localStorage
        function saveNotes() {
            localStorage.setItem('surgical_edits_notes', JSON.stringify(notes));
        }
        
        // Load dataset
        async function loadDataset(file) {
            try {
                const text = await file.text();
                dataset = JSON.parse(text);
                
                // Populate rubric filter
                const rubrics = [...new Set(dataset.map(d => d.rubric))].sort();
                const rubricSelect = document.getElementById('rubricFilter');
                rubrics.forEach(rubric => {
                    const option = document.createElement('option');
                    option.value = rubric;
                    option.textContent = rubric;
                    rubricSelect.appendChild(option);
                });
                
                applyFilters();
            } catch (error) {
                alert('Error loading dataset: ' + error.message);
                console.error(error);
            }
        }
        
        // Apply filters
        function applyFilters() {
            const mechanism = document.getElementById('mechanismFilter').value;
            const rubric = document.getElementById('rubricFilter').value;
            
            filteredDataset = dataset.filter(d => {
                if (mechanism !== 'all' && d.mechanism !== mechanism) return false;
                if (rubric !== 'all' && d.rubric !== rubric) return false;
                return true;
            });
            
            renderExamples();
        }
        
        // Render all examples
        function renderExamples() {
            const mainContent = document.getElementById('mainContent');
            const progressText = document.getElementById('progressText');
            
            if (filteredDataset.length === 0) {
                mainContent.innerHTML = '<div class="text-center text-gray-500 py-12">No examples match the current filters</div>';
                progressText.textContent = '0 / 0 examples';
                return;
            }
            
            const reviewedCount = filteredDataset.filter(d => notes[d.offer_id]).length;
            progressText.textContent = `${reviewedCount} / ${filteredDataset.length} reviewed`;
            
            mainContent.innerHTML = filteredDataset.map((example, index) => {
                const note = notes[example.offer_id] || {};
                const isReviewed = !!notes[example.offer_id];
                
                return `
                    <div class="mb-8 border rounded-lg p-6 ${example.mechanism === 'TOXIC_INJECTION' ? 'mechanism-toxic' : 'mechanism-omission'} ${isReviewed ? 'bg-green-50' : 'bg-white'}" id="example-${index}">
                        <!-- Example Header -->
                        <div class="flex items-center justify-between mb-4 pb-4 border-b">
                            <div>
                                <div class="flex items-center gap-3">
                                    <span class="text-2xl font-bold text-gray-800">#${index + 1}</span>
                                    <span class="px-3 py-1 rounded-full text-xs font-semibold ${example.mechanism === 'TOXIC_INJECTION' ? 'bg-red-100 text-red-800' : 'bg-blue-100 text-blue-800'}">
                                        ${example.mechanism}
                                    </span>
                                    <span class="px-3 py-1 rounded-full text-xs font-semibold bg-gray-100 text-gray-800">
                                        ${example.rubric}
                                    </span>
                                    <span class="text-sm text-gray-600">Offer ID: ${example.offer_id} | ROME: ${example.rome_code}</span>
                                </div>
                                ${isReviewed ? '<span class="ml-2 text-xs text-green-600">‚úì Reviewed</span>' : ''}
                            </div>
                            <button onclick="scrollToNext(${index})" class="text-sm text-blue-600 hover:text-blue-800">
                                Next ‚Üí
                            </button>
                        </div>
                        
                        <!-- Flaw Description -->
                        <div class="mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-md">
                            <h3 class="font-semibold text-gray-800 mb-2">Flaw Description:</h3>
                            <p class="text-sm text-gray-700">${escapeHtml(example.flaw_description || 'No description provided')}</p>
                        </div>
                        
                        <!-- Differences View (Default) -->
                        <div class="mb-4">
                            <div class="border rounded-md p-4 bg-gray-50">
                                <div class="bg-white rounded p-3 text-sm max-h-[600px] overflow-y-auto">
                                    ${renderDiffView(example)}
                                </div>
                            </div>
                        </div>
                        
                        <!-- Differences Highlight (for TOXIC_INJECTION) -->
                        ${example.mechanism === 'TOXIC_INJECTION' && example.flaw_span ? `
                            <div class="mb-4 p-4 bg-purple-50 border border-purple-200 rounded-md">
                                <h3 class="font-semibold text-purple-800 mb-2">Injected Text Location:</h3>
                                <p class="text-xs text-gray-600">Character span: ${example.flaw_span[0]} - ${example.flaw_span[1]}</p>
                            </div>
                        ` : ''}
                        
                        <!-- Notes Section -->
                        <div class="mt-4 pt-4 border-t">
                            <h3 class="font-semibold text-gray-800 mb-3">Your Review:</h3>
                            
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                                <label class="flex items-center gap-2 cursor-pointer">
                                    <input type="radio" name="quality-${index}" value="good" ${note.quality === 'good' ? 'checked' : ''} 
                                           onchange="updateNote(${index}, 'quality', 'good')" class="w-4 h-4">
                                    <span class="px-3 py-1 rounded text-sm ${note.quality === 'good' ? 'bg-green-200' : 'bg-gray-100'}">
                                        ‚úÖ Good/Realistic
                                    </span>
                                </label>
                                <label class="flex items-center gap-2 cursor-pointer">
                                    <input type="radio" name="quality-${index}" value="bad" ${note.quality === 'bad' ? 'checked' : ''}
                                           onchange="updateNote(${index}, 'quality', 'bad')" class="w-4 h-4">
                                    <span class="px-3 py-1 rounded text-sm ${note.quality === 'bad' ? 'bg-red-200' : 'bg-gray-100'}">
                                        ‚ùå Bad/Unrealistic
                                    </span>
                                </label>
                                <label class="flex items-center gap-2 cursor-pointer">
                                    <input type="radio" name="quality-${index}" value="unclear" ${note.quality === 'unclear' ? 'checked' : ''}
                                           onchange="updateNote(${index}, 'quality', 'unclear')" class="w-4 h-4">
                                    <span class="px-3 py-1 rounded text-sm ${note.quality === 'unclear' ? 'bg-yellow-200' : 'bg-gray-100'}">
                                        ‚ùì Unclear
                                    </span>
                                </label>
                            </div>
                            
                            <textarea 
                                id="note-${index}" 
                                placeholder="Add your notes here... (e.g., 'Too obvious', 'Subtle and realistic', 'Hard to detect', etc.)"
                                class="w-full p-3 border border-gray-300 rounded-md text-sm"
                                rows="3"
                                onchange="updateNote(${index}, 'note', this.value)"
                                onkeyup="updateNote(${index}, 'note', this.value)"
                            >${note.note || ''}</textarea>
                            
                            <div class="mt-2 flex flex-wrap gap-2">
                                <input type="text" 
                                       id="tags-${index}"
                                       placeholder="Tags (comma-separated, e.g., 'obvious, unrealistic, subtle')"
                                       class="flex-1 min-w-64 p-2 border border-gray-300 rounded-md text-sm"
                                       value="${(note.tags || []).join(', ')}"
                                       onchange="updateNote(${index}, 'tags', this.value)">
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Field mapping (French labels)
        const fieldLabels = {
            'kc_offre': 'Identifiant de l\'offre',
            'kd_datemodification': 'Date de modification',
            'dc_etatoffre': 'Etat de l\'offre',
            'dc_lbletatoffre': 'Label de l\'√©tat de l\'offre',
            'dc_rome': 'Identifiant du ROME',
            'dc_lblrome': 'Libell√© du ROME',
            'dc_appellationrome': 'Code de l\'appellation du ROME',
            'dc_lblappellationrome': 'Libell√© de l\'appellation du ROME',
            'dc_motifetat': 'Code du motif de l\'√©tat',
            'dc_lblmotifetat': 'Libell√© du motif de l\'√©tat',
            'dc_intituleoffre': 'Intitul√© de l\'offre',
            'dc_descriptifposte': 'Descriptif de l\'offre',
            'dd_datecreation': 'Date de cr√©ation',
            'dc_topoffrepartenaireaom': 'Offre partenaire',
            'da_listelangues': 'Langues exig√©es ou souhait√©es',
            'da_listepermis': 'Permis exig√©s ou souhait√©s',
            'dc_typecontrat': 'Code du type de contrat',
            'dc_lbltypecontrat': 'Type de contrat',
            'dn_dureecontrat': 'Dur√©e du contrat',
            'dc_naturecontrat': 'Code de la nature du contrat',
            'dc_lblnaturecontrat': 'Nature du contrat',
            'dc_qualification': 'Code de la qualification',
            'dc_lblqualification': 'Qualification',
            'dc_typexperienceprof': 'Code du type d\'exp√©rience',
            'dc_lblexperienceprof': 'Type d\'exp√©rience exig√©e/souhait√©e',
            'dc_typedureeexperienceprof': 'Code type de dur√©e',
            'dc_lbltypedureeexperienceprof': 'Type de dur√©e de l\'exp√©rience',
            'dn_dureeminexperienceprof': 'Dur√©e minimale de l\'exp√©rience professionnelle',
            'dc_commentaireexperienceprof': 'Commentaire exp√©rience',
            'dn_salaireminimum': 'Salaire minimum',
            'dn_salairemaximum': 'Salaire maximum',
            'dn_nbmoissalaire': 'Nombre de mois de salaire',
            'dc_commentairesalaire': 'Commentaire salaire',
            'dc_typesalaire': 'Code type de salaire',
            'dc_lbltypesalaire': 'Type de salaire',
            'da_listecomplementsalaire': 'Compl√©ments du salaire',
            'da_listecompetencessavoir': 'Comp√©tences de type Savoir',
            'da_listecompetencessavoirfaire': 'Comp√©tences de type Activit√© / Savoir-faire',
            'da_listecompetenceslibres': 'Autres comp√©tences libres',
            'da_listecompetencessavoiretre': 'Savoir-√™tre professionnels',
            'da_listeformations': 'Formations demand√©es',
            'dc_sousclassenaf': 'Code NAF',
            'dc_lblsousclassenaf': 'Libell√© NAF'
        };
        
        // Format a value in a human-friendly way
        function formatValue(key, value) {
            if (value === null || value === undefined) return null;
            
            // Handle boolean strings
            if (key === 'dc_topoffrepartenaireaom') {
                return value === 'true' || value === true ? 'Oui' : 'Non';
            }
            
            // Handle JSON list fields
            if (key.startsWith('da_liste')) {
                try {
                    const parsed = JSON.parse(value);
                    if (Array.isArray(parsed)) {
                        return parsed.map(item => {
                            // Extract the actual value from nested structure
                            const firstKey = Object.keys(item)[0];
                            const innerObj = item[firstKey];
                            if (innerObj && typeof innerObj === 'object') {
                                // Get the libelle or code value
                                const libelleKey = Object.keys(innerObj).find(k => k.includes('libelle') || k.includes('Libelle'));
                                return libelleKey ? innerObj[libelleKey] : JSON.stringify(innerObj);
                            }
                            return JSON.stringify(item);
                        }).join(', ');
                    }
                } catch (e) {
                    // Not JSON, return as is
                }
            }
            
            // Handle dates
            if (key.includes('date')) {
                return String(value);
            }
            
            // Handle numbers
            if (typeof value === 'number') {
                return String(value);
            }
            
            return String(value);
        }
        
        // Format entire offer as one big text block (human-friendly)
        function formatJobOfferFull(offer) {
            let text = '';
            
            // Put description first
            if (offer.dc_descriptifposte) {
                text += `${fieldLabels['dc_descriptifposte'] || 'Descriptif de l\'offre'}:\n${offer.dc_descriptifposte}\n\n`;
            }
            
            // Then title
            if (offer.dc_intituleoffre) {
                text += `${fieldLabels['dc_intituleoffre'] || 'Intitul√© de l\'offre'}: ${offer.dc_intituleoffre}\n\n`;
            }
            
            // Then other fields in a logical order
            const priorityFields = [
                'kc_offre', 'dc_rome', 'dc_lblrome', 'dc_appellationrome', 'dc_lblappellationrome',
                'dc_typecontrat', 'dc_lbltypecontrat', 'dn_dureecontrat', 'dc_naturecontrat', 'dc_lblnaturecontrat',
                'dc_qualification', 'dc_lblqualification',
                'dc_typexperienceprof', 'dc_lblexperienceprof', 'dc_typedureeexperienceprof', 
                'dc_lbltypedureeexperienceprof', 'dn_dureeminexperienceprof', 'dc_commentaireexperienceprof',
                'dn_salaireminimum', 'dn_salairemaximum', 'dn_nbmoissalaire', 'dc_commentairesalaire',
                'dc_typesalaire', 'dc_lbltypesalaire', 'da_listecomplementsalaire',
                'da_listelangues', 'da_listepermis',
                'da_listecompetencessavoir', 'da_listecompetencessavoirfaire', 
                'da_listecompetenceslibres', 'da_listecompetencessavoiretre',
                'da_listeformations',
                'dc_etatoffre', 'dc_lbletatoffre', 'dc_motifetat', 'dc_lblmotifetat',
                'dd_datecreation', 'kd_datemodification', 'dc_topoffrepartenaireaom',
                'dc_sousclassenaf', 'dc_lblsousclassenaf'
            ];
            
            priorityFields.forEach(key => {
                if (offer[key] !== null && offer[key] !== undefined && key !== 'dc_descriptifposte' && key !== 'dc_intituleoffre') {
                    const label = fieldLabels[key] || key;
                    const formattedValue = formatValue(key, offer[key]);
                    if (formattedValue !== null) {
                        text += `${label}: ${formattedValue}\n`;
                    }
                }
            });
            
            // Add any remaining fields not in priority list
            Object.keys(offer).forEach(key => {
                if (!priorityFields.includes(key) && offer[key] !== null && offer[key] !== undefined) {
                    const label = fieldLabels[key] || key;
                    const formattedValue = formatValue(key, offer[key]);
                    if (formattedValue !== null) {
                        text += `${label}: ${formattedValue}\n`;
                    }
                }
            });
            
            return text || 'No content';
        }
        
        // Word-level diff algorithm (DiffChecker style)
        function diffWords(oldText, newText) {
            if (!oldText && !newText) return { oldHtml: '', newHtml: '' };
            if (!oldText) {
                return {
                    oldHtml: '<span class="text-gray-400 italic">(empty)</span>',
                    newHtml: `<span class="diff-added">${escapeHtml(String(newText))}</span>`
                };
            }
            if (!newText) {
                return {
                    oldHtml: `<span class="diff-removed">${escapeHtml(String(oldText))}</span>`,
                    newHtml: '<span class="text-gray-400 italic">(empty)</span>'
                };
            }
            
            const oldStr = String(oldText);
            const newStr = String(newText);
            
            // If texts are identical, return as-is
            if (oldStr === newStr) {
                return {
                    oldHtml: escapeHtml(oldStr),
                    newHtml: escapeHtml(newStr)
                };
            }
            
            // Split into words (preserving whitespace and punctuation)
            // Use a regex that splits on word boundaries but keeps the delimiters
            const oldWords = oldStr.split(/(\s+|[.,;:!?()\[\]{}"'`-])/);
            const newWords = newStr.split(/(\s+|[.,;:!?()\[\]{}"'`-])/);
            
            // Filter out empty strings from split
            const oldWordsFiltered = oldWords.filter(w => w.length > 0);
            const newWordsFiltered = newWords.filter(w => w.length > 0);
            
            // Compute diff
            const result = computeWordDiff(oldWordsFiltered, newWordsFiltered);
            
            return {
                oldHtml: result.old.map(part => {
                    if (part.type === 'removed') {
                        return `<span class="diff-removed">${escapeHtml(part.text)}</span>`;
                    } else {
                        return escapeHtml(part.text);
                    }
                }).join(''),
                newHtml: result.new.map(part => {
                    if (part.type === 'added') {
                        return `<span class="diff-added">${escapeHtml(part.text)}</span>`;
                    } else {
                        return escapeHtml(part.text);
                    }
                }).join('')
            };
        }
        
        // Compute word-level diff using LCS-like algorithm
        function computeWordDiff(oldWords, newWords) {
            // Use dynamic programming to find longest common subsequence
            const m = oldWords.length;
            const n = newWords.length;
            
            // Build LCS table
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
            
            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    if (oldWords[i - 1] === newWords[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    } else {
                        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                    }
                }
            }
            
            // Backtrack to find the diff
            const oldResult = [];
            const newResult = [];
            let i = m;
            let j = n;
            
            while (i > 0 || j > 0) {
                if (i > 0 && j > 0 && oldWords[i - 1] === newWords[j - 1]) {
                    // Match - add as same
                    oldResult.unshift({ type: 'same', text: oldWords[i - 1] });
                    newResult.unshift({ type: 'same', text: newWords[j - 1] });
                    i--;
                    j--;
                } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
                    // Added in new
                    newResult.unshift({ type: 'added', text: newWords[j - 1] });
                    j--;
                } else if (i > 0) {
                    // Removed from old
                    oldResult.unshift({ type: 'removed', text: oldWords[i - 1] });
                    i--;
                }
            }
            
            return { old: oldResult, new: newResult };
        }
        
        // Render diff view (DiffChecker style - simple side-by-side)
        function renderDiffView(example) {
            const controlText = formatJobOfferFull(example.O_control);
            const treatmentText = formatJobOfferFull(example.O_treatment);
            
            const wordDiff = diffWords(controlText, treatmentText);
            
            return `
                <div class="grid grid-cols-2 divide-x border rounded-lg overflow-hidden bg-white">
                    <div class="p-4 bg-white">
                        <div class="text-xs font-semibold text-gray-600 mb-2">Control (Original)</div>
                        <div class="text-sm whitespace-pre-wrap leading-relaxed">${wordDiff.oldHtml}</div>
                    </div>
                    <div class="p-4 bg-white">
                        <div class="text-xs font-semibold text-gray-600 mb-2">Treatment (Modified)</div>
                        <div class="text-sm whitespace-pre-wrap leading-relaxed">${wordDiff.newHtml}</div>
                    </div>
                </div>
            `;
        }
        
        // Update note
        function updateNote(index, field, value) {
            const example = filteredDataset[index];
            if (!notes[example.offer_id]) {
                notes[example.offer_id] = {};
            }
            
            if (field === 'tags') {
                notes[example.offer_id].tags = value.split(',').map(t => t.trim()).filter(t => t);
            } else {
                notes[example.offer_id][field] = value;
            }
            
            notes[example.offer_id].timestamp = new Date().toISOString();
            notes[example.offer_id].rubric = example.rubric;
            notes[example.offer_id].mechanism = example.mechanism;
            
            saveNotes();
            
            // Update reviewed indicator
            const exampleEl = document.getElementById(`example-${index}`);
            if (notes[example.offer_id].quality) {
                exampleEl.classList.add('bg-green-50');
            }
            
            // Update progress
            const reviewedCount = filteredDataset.filter(d => notes[d.offer_id] && notes[d.offer_id].quality).length;
            document.getElementById('progressText').textContent = `${reviewedCount} / ${filteredDataset.length} reviewed`;
        }
        
        // Save notes to file
        function exportNotes() {
            const exportData = {
                timestamp: new Date().toISOString(),
                total_examples: dataset.length,
                reviewed_count: Object.keys(notes).length,
                notes: notes
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `surgical_edits_review_notes_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Scroll to next unreviewed
        function scrollToNext(currentIndex) {
            for (let i = currentIndex + 1; i < filteredDataset.length; i++) {
                if (!notes[filteredDataset[i].offer_id] || !notes[filteredDataset[i].offer_id].quality) {
                    document.getElementById(`example-${i}`).scrollIntoView({ behavior: 'smooth', block: 'start' });
                    return;
                }
            }
            alert('All examples reviewed!');
        }
        
        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadNotes();
            
            // File input
            document.getElementById('datasetInput').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    loadDataset(e.target.files[0]);
                }
            });
            
            // Filters
            document.getElementById('mechanismFilter').addEventListener('change', applyFilters);
            document.getElementById('rubricFilter').addEventListener('change', applyFilters);
            
            // Buttons
            document.getElementById('saveNotesBtn').addEventListener('click', () => {
                saveNotes();
                alert('Notes saved to browser storage!');
            });
            
            document.getElementById('exportNotesBtn').addEventListener('click', exportNotes);
            
            // Try to load default dataset
            fetch('./data/surgical_edits_dataset.json')
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    }
                    throw new Error('File not found');
                })
                .then(data => {
                    dataset = data;
                    // Populate rubric filter
                    const rubrics = [...new Set(dataset.map(d => d.rubric))].sort();
                    const rubricSelect = document.getElementById('rubricFilter');
                    rubrics.forEach(rubric => {
                        const option = document.createElement('option');
                        option.value = rubric;
                        option.textContent = rubric;
                        rubricSelect.appendChild(option);
                    });
                    applyFilters();
                })
                .catch(error => {
                    console.log('Default dataset not found, please load manually:', error);
                });
        });
    </script>
</body>
</html>

